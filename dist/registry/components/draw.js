import{S as e,G as t,_ as i,N as s,$ as n,a0 as o,a1 as r,a2 as a,a3 as h,a as l,a4 as d,a5 as c,a6 as u,P as g,E as _,a7 as p,a8 as f,s as m,b as y,c as v,a9 as C,aa as w,ab as x,ac as k,o as T,C as b}from"../../olMap-8ffb7ea3.js";import{b5 as P,a0 as S,Z as F,aw as E,T as L,a5 as G,n as M,E as I,h as N,bq as D,X as O,p as R,a6 as A,aa as V,aY as B,ap as j,a9 as U,aG as q}from"../../size-aa14a1dc.js";import{V as H,a as Y,F as X,L as W,M as z,b as J,d as K,c as Z,R as $,e as Q,v as ee}from"../../vectors-2b27bbf4.js";import{$ as te}from"../../mapDef-32126832.js";import"./toolbar.js";import{p as ie,s as se}from"../../popup-4e64157a.js";import{t as ne,g as oe,a as re}from"../../olUtils-31be321a.js";import"../../Source-441004cf.js";import"../../string-4ef30a9f.js";import"../../rasters-f91a0263.js";import"../../Overlay-e6570afb.js";class ae extends e{constructor(e,t,i){if(super(),void 0!==i&&void 0===t)this.setFlatCoordinates(i,e);else{const s=t||0;this.setCenterAndRadius(e,s,i)}}clone(){const e=new ae(this.flatCoordinates.slice(),void 0,this.layout);return e.applyProperties(this),e}closestPointXY(e,t,i,s){const n=this.flatCoordinates,o=e-n[0],r=t-n[1],a=o*o+r*r;if(a<s){if(0===a)for(let e=0;e<this.stride;++e)i[e]=n[e];else{const e=this.getRadius()/Math.sqrt(a);i[0]=n[0]+e*o,i[1]=n[1]+e*r;for(let e=2;e<this.stride;++e)i[e]=n[e]}return i.length=this.stride,a}return s}containsXY(e,t){const i=this.flatCoordinates,s=e-i[0],n=t-i[1];return s*s+n*n<=this.getRadiusSquared_()}getCenter(){return this.flatCoordinates.slice(0,this.stride)}computeExtent(e){const t=this.flatCoordinates,i=t[this.stride]-t[0];return P(t[0]-i,t[1]-i,t[0]+i,t[1]+i,e)}getRadius(){return Math.sqrt(this.getRadiusSquared_())}getRadiusSquared_(){const e=this.flatCoordinates[this.stride]-this.flatCoordinates[0],t=this.flatCoordinates[this.stride+1]-this.flatCoordinates[1];return e*e+t*t}getType(){return t.CIRCLE}intersectsExtent(e){const t=this.getExtent();if(S(e,t)){const t=this.getCenter();return e[0]<=t[0]&&e[2]>=t[0]||(e[1]<=t[1]&&e[3]>=t[1]||F(e,this.intersectsCoordinate.bind(this)))}return!1}setCenter(e){const t=this.stride,i=this.flatCoordinates[t]-this.flatCoordinates[0],s=e.slice();s[t]=s[0]+i;for(let i=1;i<t;++i)s[t+i]=e[i];this.setFlatCoordinates(this.layout,s),this.changed()}setCenterAndRadius(e,t,s){this.setLayout(s,e,0),this.flatCoordinates||(this.flatCoordinates=[]);const n=this.flatCoordinates;let o=i(n,0,e,this.stride);n[o++]=n[0]+t;for(let e=1,t=this.stride;e<t;++e)n[o++]=n[e];n.length=o,this.changed()}getCoordinates(){return null}setCoordinates(e,t){}setRadius(e){this.flatCoordinates[this.stride]=this.flatCoordinates[0]+e,this.changed()}rotate(e,t){const i=this.getCenter(),n=this.getStride();this.setCenter(s(i,0,i.length,n,e,t,i)),this.changed()}translate(e,t){const i=this.getCenter(),s=this.getStride();this.setCenter(n(i,0,i.length,s,e,t,i)),this.changed()}}const he="Point",le="LineString",de="Polygon",ce="Circle",ue="drawstart",ge="drawend",_e="drawabort";class pe extends N{constructor(e,t){super(e),this.feature=t}}class fe extends o{constructor(e){const i=e;i.stopDown||(i.stopDown=E),super(i),this.shouldHandle_=!1,this.downPx_=null,this.downTimeout_,this.lastDragTime_,this.pointerType_,this.freehand_=!1,this.source_=e.source?e.source:null,this.features_=e.features?e.features:null,this.snapTolerance_=e.snapTolerance?e.snapTolerance:12,this.type_=e.type,this.mode_=function(e){let i;e===t.POINT||e===t.MULTI_POINT?i=he:e===t.LINE_STRING||e===t.MULTI_LINE_STRING?i=le:e===t.POLYGON||e===t.MULTI_POLYGON?i=de:e===t.CIRCLE&&(i=ce);return i}(this.type_),this.stopClick_=!!e.stopClick,this.minPoints_=e.minPoints?e.minPoints:this.mode_===de?3:2,this.maxPoints_=this.mode_===ce?2:e.maxPoints?e.maxPoints:1/0,this.finishCondition_=e.finishCondition?e.finishCondition:L;let s=e.geometryFunction;if(!s){const e=this.mode_;if(e===ce)s=function(e,t,i){const s=t||new ae([NaN,NaN]),n=G(e[0]),o=r(n,G(e[e.length-1]));return s.setCenterAndRadius(n,Math.sqrt(o)),s};else{let t;e===he?t=g:e===le?t=W:e===de&&(t=_),s=function(i,s,n){return s?e===de?i[0].length?s.setCoordinates([i[0].concat([i[0][0]])]):s.setCoordinates([]):s.setCoordinates(i):s=new t(i),s}}}this.geometryFunction_=s,this.dragVertexDelay_=void 0!==e.dragVertexDelay?e.dragVertexDelay:500,this.finishCoordinate_=null,this.sketchFeature_=null,this.sketchPoint_=null,this.sketchCoords_=null,this.sketchLine_=null,this.sketchLineCoords_=null,this.squaredClickTolerance_=e.clickTolerance?e.clickTolerance*e.clickTolerance:36,this.overlay_=new H({source:new Y({useSpatialIndex:!1,wrapX:!!e.wrapX&&e.wrapX}),style:e.style?e.style:me(),updateWhileInteracting:!0}),this.geometryName_=e.geometryName,this.condition_=e.condition?e.condition:a,this.freehandCondition_,e.freehand?this.freehandCondition_=h:this.freehandCondition_=e.freehandCondition?e.freehandCondition:l,this.addEventListener(M(d.ACTIVE),this.updateState_)}setMap(e){super.setMap(e),this.updateState_()}getOverlay(){return this.overlay_}handleEvent(e){e.originalEvent.type===I.CONTEXTMENU&&e.originalEvent.preventDefault(),this.freehand_=this.mode_!==he&&this.freehandCondition_(e);let t=e.type===c.POINTERMOVE,i=!0;if(!this.freehand_&&this.lastDragTime_&&e.type===c.POINTERDRAG){Date.now()-this.lastDragTime_>=this.dragVertexDelay_?(this.downPx_=e.pixel,this.shouldHandle_=!this.freehand_,t=!0):this.lastDragTime_=void 0,this.shouldHandle_&&void 0!==this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0)}return this.freehand_&&e.type===c.POINTERDRAG&&null!==this.sketchFeature_?(this.addToDrawing_(e.coordinate),i=!1):this.freehand_&&e.type===c.POINTERDOWN?i=!1:t&&this.getPointerCount()<2?(i=e.type===c.POINTERMOVE,i&&this.freehand_?(this.handlePointerMove_(e),this.shouldHandle_&&e.originalEvent.preventDefault()):("mouse"===e.originalEvent.pointerType||e.type===c.POINTERDRAG&&void 0===this.downTimeout_)&&this.handlePointerMove_(e)):e.type===c.DBLCLICK&&(i=!1),super.handleEvent(e)&&i}handleDownEvent(e){return this.shouldHandle_=!this.freehand_,this.freehand_?(this.downPx_=e.pixel,this.finishCoordinate_||this.startDrawing_(e.coordinate),!0):this.condition_(e)?(this.lastDragTime_=Date.now(),this.downTimeout_=setTimeout(function(){this.handlePointerMove_(new u(c.POINTERMOVE,e.map,e.originalEvent,!1,e.frameState))}.bind(this),this.dragVertexDelay_),this.downPx_=e.pixel,!0):(this.lastDragTime_=void 0,!1)}handleUpEvent(e){let t=!0;if(0===this.getPointerCount())if(this.downTimeout_&&(clearTimeout(this.downTimeout_),this.downTimeout_=void 0),this.handlePointerMove_(e),this.shouldHandle_){switch(!0){case!this.finishCoordinate_:if(this.startDrawing_(e.coordinate),this.mode_!==he)break;case this.freehand_||this.atFinish_(e.pixel)&&this.finishCondition_(e):this.finishDrawing();break;case!this.freehand_:this.addToDrawing_(e.coordinate)}t=!1}else this.freehand_&&this.abortDrawing();return!t&&this.stopClick_&&e.originalEvent.stopPropagation(),t}handlePointerMove_(e){if(this.pointerType_=e.originalEvent.pointerType,this.downPx_&&(!this.freehand_&&this.shouldHandle_||this.freehand_&&!this.shouldHandle_)){const t=this.downPx_,i=e.pixel,s=t[0]-i[0],n=t[1]-i[1],o=s*s+n*n;if(this.shouldHandle_=this.freehand_?o>this.squaredClickTolerance_:o<=this.squaredClickTolerance_,!this.shouldHandle_)return}this.finishCoordinate_?this.modifyDrawing_(e.coordinate):this.createOrUpdateSketchPoint_(e)}atFinish_(e){let t=!1;if(this.sketchFeature_){let i=!1,s=[this.finishCoordinate_];const n=this.mode_;if(n===he)t=!0;else if(n===ce)t=2===this.sketchCoords_.length;else if(n===le)i=this.sketchCoords_.length>this.minPoints_;else if(n===de){const e=this.sketchCoords_;i=e[0].length>this.minPoints_,s=[e[0][0],e[0][e[0].length-2]]}if(i){const i=this.getMap();for(let n=0,o=s.length;n<o;n++){const o=s[n],r=i.getPixelFromCoordinate(o),a=e[0]-r[0],h=e[1]-r[1],l=this.freehand_?1:this.snapTolerance_;if(t=Math.sqrt(a*a+h*h)<=l,t){this.finishCoordinate_=o;break}}}}return t}createOrUpdateSketchPoint_(e){const t=e.coordinate.slice();if(this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(t)}else this.sketchPoint_=new X(new g(t)),this.updateSketchFeatures_()}createOrUpdateCustomSketchLine_(e){this.sketchLine_||(this.sketchLine_=new X);const t=e.getLinearRing(0);let i=this.sketchLine_.getGeometry();i?(i.setFlatCoordinates(t.getLayout(),t.getFlatCoordinates()),i.changed()):(i=new W(t.getFlatCoordinates(),t.getLayout()),this.sketchLine_.setGeometry(i))}startDrawing_(e){const t=this.getMap().getView().getProjection();this.finishCoordinate_=e,this.mode_===he?this.sketchCoords_=e.slice():this.mode_===de?(this.sketchCoords_=[[e.slice(),e.slice()]],this.sketchLineCoords_=this.sketchCoords_[0]):this.sketchCoords_=[e.slice(),e.slice()],this.sketchLineCoords_&&(this.sketchLine_=new X(new W(this.sketchLineCoords_)));const i=this.geometryFunction_(this.sketchCoords_,void 0,t);this.sketchFeature_=new X,this.geometryName_&&this.sketchFeature_.setGeometryName(this.geometryName_),this.sketchFeature_.setGeometry(i),this.updateSketchFeatures_(),this.dispatchEvent(new pe(ue,this.sketchFeature_))}modifyDrawing_(e){const i=this.getMap(),s=this.sketchFeature_.getGeometry(),n=i.getView().getProjection();let o,r;if(this.mode_===he?r=this.sketchCoords_:this.mode_===de?(o=this.sketchCoords_[0],r=o[o.length-1],this.atFinish_(i.getPixelFromCoordinate(e))&&(e=this.finishCoordinate_.slice())):(o=this.sketchCoords_,r=o[o.length-1]),r[0]=e[0],r[1]=e[1],this.geometryFunction_(this.sketchCoords_,s,n),this.sketchPoint_){this.sketchPoint_.getGeometry().setCoordinates(e)}if(s.getType()===t.POLYGON&&this.mode_!==de)this.createOrUpdateCustomSketchLine_(s);else if(this.sketchLineCoords_){this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_)}this.updateSketchFeatures_()}addToDrawing_(e){const t=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s,n;const o=this.mode_;o===le||o===ce?(this.finishCoordinate_=e.slice(),n=this.sketchCoords_,n.length>=this.maxPoints_&&(this.freehand_?n.pop():s=!0),n.push(e.slice()),this.geometryFunction_(n,t,i)):o===de&&(n=this.sketchCoords_[0],n.length>=this.maxPoints_&&(this.freehand_?n.pop():s=!0),n.push(e.slice()),s&&(this.finishCoordinate_=n[0]),this.geometryFunction_(this.sketchCoords_,t,i)),this.updateSketchFeatures_(),s&&this.finishDrawing()}removeLastPoint(){if(!this.sketchFeature_)return;const e=this.sketchFeature_.getGeometry(),i=this.getMap().getView().getProjection();let s;const n=this.mode_;if(n===le||n===ce){if(s=this.sketchCoords_,s.splice(-2,1),s.length>=2){this.finishCoordinate_=s[s.length-2].slice();const e=this.finishCoordinate_.slice();s[s.length-1]=e,this.sketchPoint_.setGeometry(new g(e))}this.geometryFunction_(s,e,i),e.getType()===t.POLYGON&&this.sketchLine_&&this.createOrUpdateCustomSketchLine_(e)}else if(n===de){s=this.sketchCoords_[0],s.splice(-2,1);const t=this.sketchLine_.getGeometry();if(s.length>=2){const e=s[s.length-2].slice();s[s.length-1]=e,this.sketchPoint_.setGeometry(new g(e))}t.setCoordinates(s),this.geometryFunction_(this.sketchCoords_,e,i)}1===s.length&&this.abortDrawing(),this.updateSketchFeatures_()}finishDrawing(){const e=this.abortDrawing_();if(!e)return;let i=this.sketchCoords_;const s=e.getGeometry(),n=this.getMap().getView().getProjection();this.mode_===le?(i.pop(),this.geometryFunction_(i,s,n)):this.mode_===de&&(i[0].pop(),this.geometryFunction_(i,s,n),i=s.getCoordinates()),this.type_===t.MULTI_POINT?e.setGeometry(new z([i])):this.type_===t.MULTI_LINE_STRING?e.setGeometry(new J([i])):this.type_===t.MULTI_POLYGON&&e.setGeometry(new K([i])),this.dispatchEvent(new pe(ge,e)),this.features_&&this.features_.push(e),this.source_&&this.source_.addFeature(e)}abortDrawing_(){this.finishCoordinate_=null;const e=this.sketchFeature_;return this.sketchFeature_=null,this.sketchPoint_=null,this.sketchLine_=null,this.overlay_.getSource().clear(!0),e}abortDrawing(){const e=this.abortDrawing_();e&&this.dispatchEvent(new pe(_e,e))}appendCoordinates(e){const t=this.mode_,i=!this.sketchFeature_;let s;if(i&&this.startDrawing_(e[0]),t===le||t===ce)s=this.sketchCoords_;else{if(t!==de)return;s=this.sketchCoords_&&this.sketchCoords_.length?this.sketchCoords_[0]:[]}i&&s.shift(),s.pop();for(let t=0;t<e.length;t++)this.addToDrawing_(e[t]);const n=e[e.length-1];this.addToDrawing_(n),this.modifyDrawing_(n)}extend(e){const t=e.getGeometry();this.sketchFeature_=e,this.sketchCoords_=t.getCoordinates();const i=this.sketchCoords_[this.sketchCoords_.length-1];this.finishCoordinate_=i.slice(),this.sketchCoords_.push(i.slice()),this.sketchPoint_=new X(new g(i)),this.updateSketchFeatures_(),this.dispatchEvent(new pe(ue,this.sketchFeature_))}updateSketchFeatures_(){const e=[];this.sketchFeature_&&e.push(this.sketchFeature_),this.sketchLine_&&e.push(this.sketchLine_),this.sketchPoint_&&e.push(this.sketchPoint_);const t=this.overlay_.getSource();t.clear(!0),t.addFeatures(e)}updateState_(){const e=this.getMap(),t=this.getActive();e&&t||this.abortDrawing(),this.overlay_.setMap(t?e:null)}}function me(){const e=Z();return function(t,i){return e[t.getGeometry().getType()]}}const ye=[0,0,0,0],ve=[],Ce="modifystart",we="modifyend";class xe extends N{constructor(e,t,i){super(e),this.features=t,this.mapBrowserEvent=i}}class ke extends o{constructor(e){let t;if(super(e),this.boundHandleFeatureChange_=this.handleFeatureChange_.bind(this),this.condition_=e.condition?e.condition:p,this.defaultDeleteCondition_=function(e){return f(e)&&m(e)},this.deleteCondition_=e.deleteCondition?e.deleteCondition:this.defaultDeleteCondition_,this.insertVertexCondition_=e.insertVertexCondition?e.insertVertexCondition:h,this.vertexFeature_=null,this.vertexSegments_=null,this.lastPixel_=[0,0],this.ignoreNextSingleClick_=!1,this.featuresBeingModified_=null,this.rBush_=new $,this.pixelTolerance_=void 0!==e.pixelTolerance?e.pixelTolerance:10,this.snappedToVertex_=!1,this.changingFeature_=!1,this.dragSegments_=[],this.overlay_=new H({source:new Y({useSpatialIndex:!1,wrapX:!!e.wrapX}),style:e.style?e.style:Se(),updateWhileAnimating:!0,updateWhileInteracting:!0}),this.SEGMENT_WRITERS_={Point:this.writePointGeometry_.bind(this),LineString:this.writeLineStringGeometry_.bind(this),LinearRing:this.writeLineStringGeometry_.bind(this),Polygon:this.writePolygonGeometry_.bind(this),MultiPoint:this.writeMultiPointGeometry_.bind(this),MultiLineString:this.writeMultiLineStringGeometry_.bind(this),MultiPolygon:this.writeMultiPolygonGeometry_.bind(this),Circle:this.writeCircleGeometry_.bind(this),GeometryCollection:this.writeGeometryCollectionGeometry_.bind(this)},this.source_=null,this.hitDetection_=null,e.features?t=e.features:e.source&&(this.source_=e.source,t=new y(this.source_.getFeatures()),this.source_.addEventListener(Q.ADDFEATURE,this.handleSourceAdd_.bind(this)),this.source_.addEventListener(Q.REMOVEFEATURE,this.handleSourceRemove_.bind(this))),!t)throw new Error("The modify interaction requires features, a source or a layer");e.hitDetection&&(this.hitDetection_=e.hitDetection),this.features_=t,this.features_.forEach(this.addFeature_.bind(this)),this.features_.addEventListener(v.ADD,this.handleFeatureAdd_.bind(this)),this.features_.addEventListener(v.REMOVE,this.handleFeatureRemove_.bind(this)),this.lastPointerEvent_=null,this.delta_=[0,0]}addFeature_(e){const t=e.getGeometry();if(t){const i=this.SEGMENT_WRITERS_[t.getType()];i&&i(e,t)}const i=this.getMap();i&&i.isRendered()&&this.getActive()&&this.handlePointerAtPixel_(this.lastPixel_,i),e.addEventListener(I.CHANGE,this.boundHandleFeatureChange_)}willModifyFeatures_(e,t){if(!this.featuresBeingModified_){this.featuresBeingModified_=new y;const i=this.featuresBeingModified_.getArray();for(let e=0,s=t.length;e<s;++e){const s=t[e][0].feature;-1===i.indexOf(s)&&this.featuresBeingModified_.push(s)}this.dispatchEvent(new xe(Ce,this.featuresBeingModified_,e))}}removeFeature_(e){this.removeFeatureSegmentData_(e),this.vertexFeature_&&0===this.features_.getLength()&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.removeEventListener(I.CHANGE,this.boundHandleFeatureChange_)}removeFeatureSegmentData_(e){const t=this.rBush_,i=[];t.forEach((function(t){e===t.feature&&i.push(t)}));for(let e=i.length-1;e>=0;--e){const s=i[e];for(let e=this.dragSegments_.length-1;e>=0;--e)this.dragSegments_[e][0]===s&&this.dragSegments_.splice(e,1);t.remove(s)}}setActive(e){this.vertexFeature_&&!e&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),super.setActive(e)}setMap(e){this.overlay_.setMap(e),super.setMap(e)}getOverlay(){return this.overlay_}handleSourceAdd_(e){e.feature&&this.features_.push(e.feature)}handleSourceRemove_(e){e.feature&&this.features_.remove(e.feature)}handleFeatureAdd_(e){this.addFeature_(e.element)}handleFeatureChange_(e){if(!this.changingFeature_){const t=e.target;this.removeFeature_(t),this.addFeature_(t)}}handleFeatureRemove_(e){const t=e.element;this.removeFeature_(t)}writePointGeometry_(e,t){const i=t.getCoordinates(),s={feature:e,geometry:t,segment:[i,i]};this.rBush_.insert(t.getExtent(),s)}writeMultiPointGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const n=i[s],o={feature:e,geometry:t,depth:[s],index:s,segment:[n,n]};this.rBush_.insert(t.getExtent(),o)}}writeLineStringGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length-1;s<n;++s){const n=i.slice(s,s+2),o={feature:e,geometry:t,index:s,segment:n};this.rBush_.insert(D(n),o)}}writeMultiLineStringGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const n=i[s];for(let i=0,o=n.length-1;i<o;++i){const o=n.slice(i,i+2),r={feature:e,geometry:t,depth:[s],index:i,segment:o};this.rBush_.insert(D(o),r)}}}writePolygonGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const n=i[s];for(let i=0,o=n.length-1;i<o;++i){const o=n.slice(i,i+2),r={feature:e,geometry:t,depth:[s],index:i,segment:o};this.rBush_.insert(D(o),r)}}}writeMultiPolygonGeometry_(e,t){const i=t.getCoordinates();for(let s=0,n=i.length;s<n;++s){const n=i[s];for(let i=0,o=n.length;i<o;++i){const o=n[i];for(let n=0,r=o.length-1;n<r;++n){const r=o.slice(n,n+2),a={feature:e,geometry:t,depth:[i,s],index:n,segment:r};this.rBush_.insert(D(r),a)}}}}writeCircleGeometry_(e,t){const i=t.getCenter(),s={feature:e,geometry:t,index:0,segment:[i,i]},n={feature:e,geometry:t,index:1,segment:[i,i]},o=[s,n];s.featureSegments=o,n.featureSegments=o,this.rBush_.insert(O(i),s);let r=t;this.rBush_.insert(r.getExtent(),n)}writeGeometryCollectionGeometry_(e,t){const i=t.getGeometriesArray();for(let t=0;t<i.length;++t){const s=i[t];(0,this.SEGMENT_WRITERS_[s.getType()])(e,s)}}createOrUpdateVertexFeature_(e,t,i){let s=this.vertexFeature_;if(s){s.getGeometry().setCoordinates(e)}else s=new X(new g(e)),this.vertexFeature_=s,this.overlay_.getSource().addFeature(s);return s.set("features",t),s.set("geometries",i),s}handleEvent(e){if(!e.originalEvent)return!0;let t;return this.lastPointerEvent_=e,e.map.getView().getInteracting()||e.type!=c.POINTERMOVE||this.handlingDownUpSequence||this.handlePointerMove_(e),this.vertexFeature_&&this.deleteCondition_(e)&&(t=!(e.type!=c.SINGLECLICK||!this.ignoreNextSingleClick_)||this.removePoint()),e.type==c.SINGLECLICK&&(this.ignoreNextSingleClick_=!1),super.handleEvent(e)&&!t}handleDragEvent(e){this.ignoreNextSingleClick_=!1,this.willModifyFeatures_(e,this.dragSegments_);const i=[e.coordinate[0]+this.delta_[0],e.coordinate[1]+this.delta_[1]],s=[],n=[];for(let o=0,r=this.dragSegments_.length;o<r;++o){const r=this.dragSegments_[o],a=r[0],h=a.feature;-1===s.indexOf(h)&&s.push(h);const l=a.geometry;-1===n.indexOf(l)&&n.push(l);const d=a.depth;let c;const u=a.segment,g=r[1];for(;i.length<l.getStride();)i.push(u[g][i.length]);switch(l.getType()){case t.POINT:c=i,u[0]=i,u[1]=i;break;case t.MULTI_POINT:c=l.getCoordinates(),c[a.index]=i,u[0]=i,u[1]=i;break;case t.LINE_STRING:c=l.getCoordinates(),c[a.index+g]=i,u[g]=i;break;case t.MULTI_LINE_STRING:case t.POLYGON:c=l.getCoordinates(),c[d[0]][a.index+g]=i,u[g]=i;break;case t.MULTI_POLYGON:c=l.getCoordinates(),c[d[1]][d[0]][a.index+g]=i,u[g]=i;break;case t.CIRCLE:if(u[0]=i,u[1]=i,0===a.index)this.changingFeature_=!0,l.setCenter(i),this.changingFeature_=!1;else{this.changingFeature_=!0,e.map.getView().getProjection();let t=C(G(l.getCenter()),G(i));l.setRadius(t),this.changingFeature_=!1}}c&&this.setGeometryCoordinates_(l,c)}this.createOrUpdateVertexFeature_(i,s,n)}handleDownEvent(e){if(!this.condition_(e))return!1;const i=e.coordinate;this.handlePointerAtPixel_(e.pixel,e.map,i),this.dragSegments_.length=0,this.featuresBeingModified_=null;const s=this.vertexFeature_;if(s){e.map.getView().getProjection();const n=[],o=s.getGeometry().getCoordinates(),r=D([o]),a=this.rBush_.getInExtent(r),h={};a.sort(Te);for(let s=0,r=a.length;s<r;++s){const r=a[s],l=r.segment;let d=R(r.geometry);const c=r.depth;if(c&&(d+="-"+c.join("-")),h[d]||(h[d]=new Array(2)),r.geometry.getType()!==t.CIRCLE||1!==r.index)if(!w(l[0],o)||h[d][0])if(!w(l[1],o)||h[d][1])R(l)in this.vertexSegments_&&!h[d][0]&&!h[d][1]&&this.insertVertexCondition_(e)&&n.push(r);else{if((r.geometry.getType()===t.LINE_STRING||r.geometry.getType()===t.MULTI_LINE_STRING)&&h[d][0]&&0===h[d][0].index)continue;this.dragSegments_.push([r,1]),h[d][1]=r}else this.dragSegments_.push([r,0]),h[d][0]=r;else{const e=Pe(i,r);w(e,o)&&!h[d][0]&&(this.dragSegments_.push([r,0]),h[d][0]=r)}}n.length&&this.willModifyFeatures_(e,[n]);for(let e=n.length-1;e>=0;--e)this.insertVertex_(n[e],o)}return!!this.vertexFeature_}handleUpEvent(e){for(let e=this.dragSegments_.length-1;e>=0;--e){const i=this.dragSegments_[e][0],s=i.geometry;if(s.getType()===t.CIRCLE){const e=s.getCenter(),t=i.featureSegments[0],n=i.featureSegments[1];t.segment[0]=e,t.segment[1]=e,n.segment[0]=e,n.segment[1]=e,this.rBush_.update(O(e),t);let o=s;this.rBush_.update(o.getExtent(),n)}else this.rBush_.update(D(i.segment),i)}return this.featuresBeingModified_&&(this.dispatchEvent(new xe(we,this.featuresBeingModified_,e)),this.featuresBeingModified_=null),!1}handlePointerMove_(e){this.lastPixel_=e.pixel,this.handlePointerAtPixel_(e.pixel,e.map,e.coordinate)}handlePointerAtPixel_(e,i,s){const n=s||i.getCoordinateFromPixel(e);i.getView().getProjection();const o=function(e,t){return be(n,e)-be(n,t)};let a,h;if(this.hitDetection_){const s="object"==typeof this.hitDetection_?e=>e===this.hitDetection_:void 0;i.forEachFeatureAtPixel(e,(e,i,s)=>{if((s=s||e.getGeometry()).getType()===t.POINT){h=s;const t=s.getCoordinates();a=[{feature:e,geometry:s,segment:[t,t]}]}return!0},{layerFilter:s})}if(!a){const e=A(O(n,ye)),t=i.getView().getResolution()*this.pixelTolerance_,s=V(B(e,t,ye));a=this.rBush_.getInExtent(s)}if(a&&a.length>0){const s=a.sort(o)[0],l=s.segment;let d=Pe(n,s);const c=i.getPixelFromCoordinate(d);let u=C(e,c);if(h||u<=this.pixelTolerance_){const e={};if(e[R(l)]=!0,this.delta_[0]=d[0]-n[0],this.delta_[1]=d[1]-n[1],s.geometry.getType()===t.CIRCLE&&1===s.index)this.snappedToVertex_=!0,this.createOrUpdateVertexFeature_(d,[s.feature],[s.geometry]);else{const t=i.getPixelFromCoordinate(l[0]),n=i.getPixelFromCoordinate(l[1]),o=r(c,t),h=r(c,n);u=Math.sqrt(Math.min(o,h)),this.snappedToVertex_=u<=this.pixelTolerance_,this.snappedToVertex_&&(d=o>h?l[1]:l[0]),this.createOrUpdateVertexFeature_(d,[s.feature],[s.geometry]);const g={};g[R(s.geometry)]=!0;for(let t=1,i=a.length;t<i;++t){const i=a[t].segment;if(!(w(l[0],i[0])&&w(l[1],i[1])||w(l[0],i[1])&&w(l[1],i[0])))break;{const s=R(a[t].geometry);s in g||(g[s]=!0,e[R(i)]=!0)}}}return void(this.vertexSegments_=e)}}this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null)}insertVertex_(e,i){const s=e.segment,n=e.feature,o=e.geometry,r=e.depth,a=e.index;let h;for(;i.length<o.getStride();)i.push(0);switch(o.getType()){case t.MULTI_LINE_STRING:case t.POLYGON:h=o.getCoordinates(),h[r[0]].splice(a+1,0,i);break;case t.MULTI_POLYGON:h=o.getCoordinates(),h[r[1]][r[0]].splice(a+1,0,i);break;case t.LINE_STRING:h=o.getCoordinates(),h.splice(a+1,0,i);break;default:return}this.setGeometryCoordinates_(o,h);const l=this.rBush_;l.remove(e),this.updateSegmentIndices_(o,a,r,1);const d={segment:[s[0],i],feature:n,geometry:o,depth:r,index:a};l.insert(D(d.segment),d),this.dragSegments_.push([d,1]);const c={segment:[i,s[1]],feature:n,geometry:o,depth:r,index:a+1};l.insert(D(c.segment),c),this.dragSegments_.push([c,0]),this.ignoreNextSingleClick_=!0}removePoint(){if(this.lastPointerEvent_&&this.lastPointerEvent_.type!=c.POINTERDRAG){const e=this.lastPointerEvent_;this.willModifyFeatures_(e,this.dragSegments_);const t=this.removeVertex_();return this.dispatchEvent(new xe(we,this.featuresBeingModified_,e)),this.featuresBeingModified_=null,t}return!1}removeVertex_(){const e=this.dragSegments_,i={};let s,n,o,r,a,h,l,d,c,u,g,_=!1;for(a=e.length-1;a>=0;--a)o=e[a],u=o[0],g=R(u.feature),u.depth&&(g+="-"+u.depth.join("-")),g in i||(i[g]={}),0===o[1]?(i[g].right=u,i[g].index=u.index):1==o[1]&&(i[g].left=u,i[g].index=u.index+1);for(g in i){switch(c=i[g].right,l=i[g].left,h=i[g].index,d=h-1,u=void 0!==l?l:c,d<0&&(d=0),r=u.geometry,n=r.getCoordinates(),s=n,_=!1,r.getType()){case t.MULTI_LINE_STRING:n[u.depth[0]].length>2&&(n[u.depth[0]].splice(h,1),_=!0);break;case t.LINE_STRING:n.length>2&&(n.splice(h,1),_=!0);break;case t.MULTI_POLYGON:s=s[u.depth[1]];case t.POLYGON:s=s[u.depth[0]],s.length>4&&(h==s.length-1&&(h=0),s.splice(h,1),_=!0,0===h&&(s.pop(),s.push(s[0]),d=s.length-1))}if(_){this.setGeometryCoordinates_(r,n);const t=[];if(void 0!==l&&(this.rBush_.remove(l),t.push(l.segment[0])),void 0!==c&&(this.rBush_.remove(c),t.push(c.segment[1])),void 0!==l&&void 0!==c){const e={depth:u.depth,feature:u.feature,geometry:u.geometry,index:d,segment:t};this.rBush_.insert(D(e.segment),e)}this.updateSegmentIndices_(r,h,u.depth,-1),this.vertexFeature_&&(this.overlay_.getSource().removeFeature(this.vertexFeature_),this.vertexFeature_=null),e.length=0}}return _}setGeometryCoordinates_(e,t){this.changingFeature_=!0,e.setCoordinates(t),this.changingFeature_=!1}updateSegmentIndices_(e,t,i,s){this.rBush_.forEachInExtent(e.getExtent(),(function(n){n.geometry===e&&(void 0===i||void 0===n.depth||j(n.depth,i))&&n.index>t&&(n.index+=s)}))}}function Te(e,t){return e.index-t.index}function be(e,i,s){const n=i.geometry;if(n.getType()===t.CIRCLE){let t=n;if(1===i.index){const i=r(t.getCenter(),G(e)),s=Math.sqrt(i)-t.getRadius();return s*s}}const o=G(e);return ve[0]=G(i.segment[0]),ve[1]=G(i.segment[1]),k(o,ve)}function Pe(e,i,s){const n=i.geometry;if(n.getType()===t.CIRCLE&&1===i.index){return U(n.getClosestPoint(G(e)))}const o=G(e);return ve[0]=G(i.segment[0]),ve[1]=G(i.segment[1]),U(x(o,ve))}function Se(){const e=Z();return function(i,s){return e[t.POINT]}}const Fe=T.get(),Ee=new b('\n<template id="drawtemplate">\n  <style>\n    .fa-select {\n      font-family: sans-serif, \'FontAwesome\';\n      font-size: 1em;\n    }\n    #drawtype {\n      position: absolute;\n      top: 120px;\n      left: 10px\n    }\n  </style>\n  <div id="drawtools">\n    <select id="drawtype" class="fa-select" title="Select edit tool">\n      <option value="choose">&#xf107; choose tool</option>\n      <option value="point">&#xf192; draw point</option>\n      <option value="ls">&#xe805; draw line</option>\n      <option value="poly">&#xe807; draw polygon</option>\n      <option value="modify">&#xf047; move</option>\n      <option value="modAtts">&#xe801; edit</option>\n      <option value="deleet">&#xf1f8; delete</option>\n      <option value="split">&#xe802; split line</option>\n      <option value="join">&#xe806; join lines</option>\n      <option value="save">&#xe804; save changes</option>\n      <option value="saveall">&#xe804; save all</option>\n      <option value="clear">&#xf12d; clear changes</option>\n      <option value="hide">&#xf204; hide me</option>\n    </select>\n  </div>\n</template>\n\n<template id="featureformtemplate">\n  <style>\n    #featureform {\n      background-color: white;\n      padding: 1px;\n      border: solid black;\n      width: 300px;\n    }\n    .attributetitle {\n      background-color: #6fc;\n      text-align: center;\n    }\n  </style>\n  <div id="featureform">\n    <div class="attributetitle"><i>Enter attributes</i></div>\n    <label>Id </label><input type="text" size="5" id="featureformid">\n    <div id="featureformAtts">\n      <template>\n        <div>\n          <label>Name <input type="text" size="5"></label>\n          <label>Value <input type="text" size="10"></label>\n        </div>\n      </template>\n      <button id="plusbutton">+</button>\n    </div>\n    <button id="featurebutton" class="fa fa-check-square-o"></button>\n  </div>\n</template>\n\n<template id="drawhelptemplate">\n  <section>\n    <div id="draw-title" class="helptitle">Draw tools</div>\n    <div id="draw-content" class="helpcontent">\n      <div id="draw-text">\n        <p>Select appropriate tool. Only one tool can be active at one time.</p>\n        <p>The three <b>draw tools</b> enable you to draw points, linestrings and polygons. Double-click for the last point of a linestring, and re-click on the start point to close a polygon. On completion, you are prompted to enter the name/value attributes for the feature; attributes named \'name\' or \'title\' are used as the tooltip identifier. \'id\' is a special identifying attribute; this must be unique. Otherwise, you can enter any attribute names you like.</p>\n        <p><b>Move</b> enables you to move a point, or any vector point of a linestring/polygon. Click on a section of a linestring or polygon to create a new vector at that point. Click on an existing vector point on a linestring or polygon to delete it.</p>\n        <p><b>Edit</b> is for editing the feature attributes.</p>\n        <p>Select <b>Delete</b> and then click on the feature you want to delete.</p>\n        <p>To use the <b>Split</b> tool, select the linestring you want to split, and then move the cursor to the point at which you want to split, then click. This will split the line, and you can edit the vector points or the attributes of the new lines. You cannot split at an existing vertex; to do this, drag the vertex slightly, so the line is split at this new point. MultiLineStrings with more than 1 LineString cannot be split.</p>\n        <p>To use the <b>Join</b> tool, first make sure the ends of the two lines to be joined are adjacent; then select the tool, and then select the 2 lines by clicking one, then clicking the second with the shift key. This only works on LineStrings, not MultiLineStrings.</p>\n        <p>The <b>save</b> tools will save either the changed features, or all the features currently displayed, to the \'feature output\' section of the toolbar. You can either copy this into a file, or use the \'Download\' link to save as a file on your device. By default, this is GeoJSON output, but this can be changed to KML or GPX output by using the dropdown selection, and clicking \'Reserialise\'. MongoDB output (GeoJSON geometries with attributes at the top level) is also possible. LineString and Polygon geometries can be simplified (Douglas-Peucker). And if there is only one feature, for GeoJSON the geometry only can be output.</p>\n        <p><b>Clear changes</b> will delete all the new/changed features.</p>\n        <p>Note that all newly drawn features will be added to the \'Drawn\' layer. A feature in another layer can be modified/deleted, but will be moved to the \'Drawn\' layer. You cannot at present add features to another layer.</p>\n      </div>\n    </div>\n  </section>\n</template>\n',"draw");T.addControl(Ee.getTemplate("draw"));const Le=ie.getOverlay();let Ge;ee.add({vectors:[{id:"Drawn"}]});const Me=ee.getLayers().item(ee.getLayers().get("length")-1).get("source"),Ie=se.get().getFeatures(),Ne={point:new fe({source:Me,type:"Point"}),ls:new fe({source:Me,type:"LineString"}),poly:new fe({source:Me,type:"Polygon"}),modify:new ke({features:Ie}),split:new ke({features:Ie,deleteCondition:function(){return!1}})};let De;const Oe=Ee.getTemplate("featureform");function Re(){const e=this.parentNode.querySelector("template"),t=e.content.firstElementChild.cloneNode(!0);te("#featureformAtts").insertBefore(t,e);const i=te("#featureformAtts").querySelectorAll("input");i[i.length-2].focus()}function Ae(e){const t=Le.get("element");for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(Oe.cloneNode(!0)),te("#featureformid").value="",te("#plusbutton").onclick=Re,te("#featurebutton").onclick=()=>{te("#featureformid").value&&e.feature.setId(te("#featureformid").value);const i=te("#featureformAtts").querySelectorAll("div");for(let t=0;t<i.length;t++){const s=i[t].querySelectorAll("input");s[0].value&&e.feature.set(s[0].value,s[1].value)}t.style.display="none"},Le.set("position",Fe.get("view").get("center")),t.style.display="block",te("#featureformid").focus(),De&&q(De)}Ne.point.on("drawend",Ae),Ne.ls.on("drawend",Ae),Ne.poly.on("drawend",Ae),Ne.ls.on("drawstart",e=>{let t=e.coordinate;De=e.feature.getGeometry().on("change",e=>{t=e.target.getLastCoordinate();const i=ne(e.target,Fe.get("view").getProjection()),s=oe(i);Le.get("element").innerHTML=Math.round(.1*s)/100+" km",Le.set("position",t),Le.get("element").style.display="block"})}),Ne.poly.on("drawstart",e=>{let t=e.coordinate;De=e.feature.getGeometry().on("change",e=>{t=e.target.getInteriorPoint().getCoordinates();const i=ne(e.target,Fe.get("view").getProjection()),s=re(i);Le.get("element").innerHTML=Math.round(s/1e6*100)/100+" km<sup>2</sup>",Le.set("position",t),Le.get("element").style.display="block"})}),Ne.modify.on("modifyend",e=>{const t=e.features.item(0),i=se.get().getLayer(t);"Drawn"!==i.get("id")&&(i.get("source").removeFeature(t),Me.addFeatures([t]),Ie.clear())});for(const e in Ne)Fe.addInteraction(Ne[e]),Ne[e].set("active",!1);let Ve,Be=!1,je=!1;te("#drawtype").onchange=function e(t){Ie.clear();for(const e in Ne)Ne[e].set("active",!1);Ne[t.target.value]&&Ne[t.target.value].set("active",!0);"deleet"==t.target.value?(Ve=Ie.on("add",e=>{se.get().getLayer(e.element).get("source").removeFeature(e.element),Ie.clear()}),Be=!0):Be&&(q(Ve),Be=!1);"hide"==t.target.value||"choose"==t.target.value?(se.drawOff(),"hide"==t.target.value&&(this.style.display="none",te("#drawoption").style.display="block",te("#drawoption").value="redraw",te("#drawtype").value="choose")):se.drawOn();-1==["point","ls","poly"].indexOf(t.target.value)?se.get().set("active",!0):se.get().set("active",!1);"modAtts"==t.target.value?(Ve=Ie.on("add",e=>{const t=Le.get("element");for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(Oe.cloneNode(!0));const i=e.element;te("#featureformid").value=i.getId();const s=i.getProperties(),n=te("#featureformAtts");for(const e in s)if("geometry"!=e){const t=n.querySelector("template").content.firstElementChild.cloneNode(!0),i=t.querySelectorAll("input");i[0].value=e,i[1].value=s[e],n.insertBefore(t,n.firstElementChild)}te("#plusbutton").onclick=Re,te("#featurebutton").onclick=()=>{i.setId(te("#featureformid").value);const e=te("#featureformAtts").querySelectorAll("div");for(let t=0;t<e.length;t++){const s=e[t].querySelectorAll("input");s[1].value?i.set(s[0].value,s[1].value):i.unset(s[0].value)}t.style.display="none";const s=se.get().getLayer(i);"Drawn"!==s.get("id")&&(s.get("source").removeFeature(i),Me.addFeatures([i]))},Le.set("position",Fe.get("view").get("center")),t.style.display="block"}),je=!0):je&&(q(Ve),je=!1);"save"!=t.target.value&&"saveall"!=t.target.value||import("./serialise.js").then(e=>e.default(t.target.value,"Drawn"));if("split"==t.target.value){let i;se.get().once("select",e=>{if(e.selected[0]){const t=e.selected[0].getGeometry();t.getType()&&"LineString"==t.getType()?i=t.getCoordinates():t.getType()&&"MultiLineString"==t.getType()&&1===t.getCoordinates().length&&(i=t.getCoordinates()[0])}}),Ne.split.once("modifyend",s=>{const n=s.features.item(0);if(!n.getGeometry().getType())return;const o=n.getGeometry().getType();let r=n.getGeometry().getCoordinates();if("MultiLineString"===o){if(1!==r.length)return;r=r[0]}function a(e,t){return e.some((function(e){return t.toString()==e.toString()}))}let h=0;for(;h<r.length&&!0===a(i,r[h]);)h++;const l=r.slice(0,h+1),d=r.slice(h),c=n.getProperties();c.geometry=new W(l);const u=new X(c);c.geometry=new W(d);const g=new X(c);Me.addFeatures([u,g]),se.get().getLayer(n).get("source").removeFeature(n),Ie.clear(),t.target.value="choose",e(t)})}"join"==t.target.value?Ge=se.get().on("select",e=>{if(2==Ie.get("length")){const e=Ie.item(0),t=Ie.item(1),i=e.getProperties();i.geometry=new W(e.getGeometry().getCoordinates().concat(t.getGeometry().getCoordinates().slice(1)));const s=new X(i);Ie.clear(),se.get().getLayer(t).get("source").removeFeature(t),se.get().getLayer(e).get("source").removeFeature(e),Me.addFeatures([s])}}):Ge&&(q(Ge),Ge=null);"clear"==t.target.value&&Me.clear();te("#drawtype").blur()},te("#help-content").appendChild(Ee.getTemplate("drawhelp")),te("#draw-title").addEventListener("click",(function(){const e=this.nextElementSibling;e.style.display="block"==e.style.display?"none":"block"}));
